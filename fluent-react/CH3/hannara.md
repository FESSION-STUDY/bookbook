# Chapter 3 가상 DOM

## 대주제

### depth1

#### depth2

##### depth3

> 목차
> 3.1 가상 DOM 소개
> 3.2 실제 DOM
> 3.2.1 실제 DOM의 문제점 - 성능 - 브라우저 간 호환성 - 통합 인터페이스 - 네이티브 이벤트에 접근
> 3.2.2 문서조각 - 일괄 업데이트 - 메모리 효율성 - 중복 렌더링 방지 - 효율적인 비교 알고리즘 - 단일 렌더링
> 3.3 가상 DOM 작동 방식
> 3.3.1 리액트 엘리먼트 - `$$typeof` - type - ref - props - `_owner` - `_store`
> 3.3.2 가상 DOM 과 실제 DOM의 비교
> 3.3.3 효율적인 업데이트 - 불필요한 리렌더링
> 3.4 돌아보기
> 3.5 복습하기

## 가상 DOM 소개

가상 DOM은 HTML 문서를 자바스크립트 객체로 모델링한 것

- DOM = 문서 객체 모델
- 재조정 : 리액트는 UI를 변경 지시를 할 때마다 가상 DOM을 먼저 업데이트한 후 가상 DOM의 변경 사항에 맞춰 실제 DOM을 업데이트 하는 과정을 말합니다.
- 가상 DOM업데이트는 실제 페이지 레이아웃을 변경하지 않아 빠르게 동작.
  - 가상 DOM이 업데이트되면 비교 알고리즘으로 가상 DOM 이전과 새버전의 차이점을 식별
  - 업데이트에 필요한 최소한 변경 사항을 선정하고 적용.

## 실제 DOM

Javascript객체, 웹페이지의 현재 상태를 실시간으로 표현한 것, 사용자가 페이지와 상호작용하면 업데이트

- DOM 트리에서 각 노드를 JavaScript를 통해 조작할 수 있다.
- ex) document.querySelector를 사용해 특정 엘리먼트를 검색 가능
  - document.querySelector메서드는 크고 복잡한 문서에서는 속도가 느려진다.
  - document.getElementById는 고유한 id 속성을 찾기에 효율적일 수 있다.

### 3.2.1 실제 DOM의 문제점

#### 성능

- 엘리먼트 추가, 제거, 업데이트할 때마다 브라우저는 **레이아웃을 다시 계산하고 다시 그림**
- 이는 비용이 비싸고 속도 또한 느려짐
- ex) offsetWidth속성을 읽는건 레이아웃을 다시 계산(리플로)해서 많은 비용이 발생함
- 이런 문제를 리액트는 가상DOM을 실제 DOM사이 중간 계층으로 사용해 문제를 해결

#### 브라우저 간 호환성

- 브라우저마다 문서 모델링 방식이 달라 일관성이 보장되지 않는다는 문제가 있다.
- React에서는 **합성 이벤트 시스템**이 이것을 해결해 줄 수 있다.
  - **SyntheicEvent**는 브라우저 기본 이벤트를 둘러싼 래퍼 객체로 여러 브라우저를 대응하기 위해 설계되어있다. -> 일관성을 보장할 수 있다.
  - ##### 통합 인터페이스
    - SyntheticEvent는 각각의 브라우저 이벤트를 처리하는 방식이 다른 것을 해결하기 위해 "추상화와 상호작용하는 일관된 방법을 제공"하여 특정 브라우저에 맞춤 코드를 작성하지 않도록 함
    - ![[스크린샷 2025-04-18 오후 1.55.41.png]]
  - ##### 이벤트 위임
    - React는 이벤트 리스너를 루트에서 이벤트를 받게하여 구형 브라우저에서 특정 엘리먼트에서 일부 이벤트를 사용할 수 없는 문제를 방지합니다.
  - ##### 다양한 기능 개선
    - 네이티브 브라우저에서 이벤트가 일관적이지 않는 것을 해결함
      - 예) onChange event
        - 일부 브라우저에서 `input` 태그의 onChange이벤트는 포커싱을 잃을 때 변경되는 것이 있다.
        - `select` 는 브라우저에 따라 선택된 옵션을 다시 선택할 때 이벤트가 발생하기도 한다
        - -> SyntheticEvent 는 입력 엘리먼트 전체에 onChange 이벤트 동작을 정규화
          - `input` 에서 onChange 이벤트는 키를 입력할 때마다 발생시켜 실시간 피드백 제공
          - `select`에서 선택한 값이 아닌 옵션을 선택할 때마다 발생시킴
  - ##### 네이티브 이벤트에 접근
    - 웹 브라우저의 네이티브 이벤트가 필요하면 `event.nativeEnvent`를 통해 접근하게끔함

### 3.2.2 문서조각

> [!note]
> 문서조각은 **DOM 노드를 저장하는 가벼운 컨테이너** 입니다.
>
> - 기본 DOM에 영향을 주지 않고 여러가지 업데이트를 수행하는 "_임시 저장소_" 처럼 동작합니다.
> - 업데이트 완료하면 "문서 조각"을 DOM에 추가하는 방식으로 리플로, 리페인팅을 한 번만 발생
>   - 이는 리액트 가상 DOM과 비슷

#### "문서조각"의 성능 이점

- ##### 일괄 업데이트
  - 문서 조각 안에서의 변경사항을 일괄적으로 처리해 한번에 DOM에 업데이트하여 리플로우 리페인팅과정이 최소한으로 수행됨
- ##### 메모리 효율성
  - 문서 조각에 추가된 노드는 실제 DOM에서 제거됨 -> 재정렬할 때 메모리 사용량 최적화
- ##### 중복 렌더링 방지
  - 문서조각은 활성화된 DOM트리에 속하지 않아 실제 문서에 영향을 주지 않는다.
    - 스타일, 스크립트도 적용되지 않는다.
  - 스타일 재계산, 스크립트 실행 수행을 중복되지 않게 한다.

#### "리액트의" 가상 DOM

가상 DOM은 문서 조각 개념에 좀 더 나은 방식으로 구현

- ##### 일괄 업데이트
  - 여러 변경 사항을 한번에 처리
    - 상태나 프롭이 변경되면 가상 DOM에 변경 사항을 먼저 적용함
- ##### 효율적인 비교 알고리즘
  - 변경사항이 적용되면 가상 DOM과 실제 DOM의 차이점을 확인함
  - 실제 DOM에 필요한 변경만 이뤄짐
- ##### 단일 렌더링
  - 식별된 차이점을 한 번에 처리해 실제 DOM에 업데이트
  - 리플로, 리페인팅 최소화

### 3.3 가상 DOM 작동방식

> [!note]
> 가상 DOM은 실제 DOM의 문제점을 해결한 기술
>
> - 실제 DOM을 수정하지 않고 변경사항을 찾아 비교하여 한 번에 업데이트를 시킴
> - 브라우저마다 추상화, 일관된 API를 제공해 개선된 업데이트 환경을 제공

#### 3.3.1 리액트 엘리먼트

> 리액트에서는 사용자 인터페이즈 컴포넌트, HTML 엘리먼트를 *리액트 엘리먼트 트리*로 표현합니다
>
> - React.createElement 함수를 사용해 만들 수 있음

```js
const element = React.createElement("div", { className: "my-class" }, "Hello, world!");
// <div> 엘리먼트에 className이 my-class, 텍스트컨텐츠가 Hello,world인 리액트 엘리먼트가 생성
```

![[스크린샷 2025-04-18 오후 2.17.33.png]]

##### typeof (`$$typeof`)

- 객체가 유효한 리액트 엘리먼트인지 확인하는 Symbol
- 리액트 엘리먼트 종류를 식별하는 표시자 역할

##### type

- 엘리먼트가 나타내는 컴포넌트 종류를 알려주는 역할
- 문자열이거나 함수
  - class인 경우 단계적으로 폐지될 예정이라고 합니다.
  - 문자열인 경우 : "div, span" 과 같은 HTML 태그이름
  - 함수인 경우 : JSX를 반환

##### ref

- 부모컴포넌트가 기본 DOM노드에 참조를 요청할 때 사용
- 보통 DOM을 직접 조작해야할 경우 사용

##### props

- 컴포넌트에 전달될 속성과 props를 포함하는 객체

##### owner (`_owner`)

- 프로덕션 빌드가 아닐 때만 접근 가능
- 생성한 컴포넌트를 추적하기 위한 내부적으로 사용되는 속성
- prop, 상태가 변경될 때 엘리먼트의 업데이트를 담당할 컴포넌트를 _"결정"_ 할 때 사용

##### store (`_store`)

- 엘리먼트에 추가 데이터를 저장하기 위해 내부적으로 사용하는 "객체"
- **특정 속성, 값은 직접 접근하면 안됨**
- `_source`, `_owner` `_self` 와 같은 내부적으로 엘리먼트 상태, 컨텍스트를 추적할 때 사용됨

#### 3.3.2 가상 DOM과 실제 DOM 비교

##### React.createElement, document.createElement

- 둘 다 새로운 엘리먼트를 생성한다.
- React.createElement는 React 엘리먼트를 생성한다.
  - 메모리에 새로운 가상 엘리먼트를 생성
- document,createElement는 DOM 노드를 생성한다.
  - .appendChild 와 같은 API를 사용해 DOM에 추가되기 전 메모리에 엘리먼트를 생성하는 메서드

리액트의 가상 DOM은 트리화로 엘리먼트 구조를 표현한다는 점에서 실제 DOM과 비슷하다.

- 리액트 컴포넌트가 렌더링되고 새로운 가상 DOM트리를 생성한다.
- 이전 가상 DOM트리와 비교한다
- 이전 가상 DOM트리와 새 가상 DOM트리를 일치화하도록 업데이트
  - 최소 변경 횟수를 계산한다. -> **재조정 프로세스**

#### 3.3.3 효율적인 업데이트

**상태나 prop이 변경**되면 새로운 리액트 엘리먼트 트리를 생성한다.

- **비교 알고리즘**을 사용해 새로운 트리와 이전 트리를 비교한다.
  - 디핑(diffing) = 어떤 부분이 변경되었는지 알아내는 작업
- 비교한 값을 기준으로 실제 DOM업데이트에 필요한 **최소한의 변경 사항**을 결정
- 비교할 때는 재귀적으로 이뤄진다

##### 비교 알고리즘 작동 과정

- 두 가지의 트리의 루트 노드가 다르다 => 기존 전체를 새로운 트리로 교체
- 루트 노드가 동일하다 => 노드 속성이 변경된 경우에만 업데이트
- 자식 노드가 다르다 => 변경된 자식 노드만 변경, 하위 트리 전체를 생성하지 않는다.
- 노드 자식들이 동일 But 순서가 변경 => 노드를 재생성하지 않고 실제 DOM에서 노드 순서를 다시 결정
- 트리에서 노드가 제거되면 => 실제 DOM에서 노드를 제거
- 트리에 새 노드가 추가되면 => 추가된 노드를 실제 DOM에 추가
- 노드 종류가 변경되면 => 이전 노드를 제거하고 변경된 새 노드를 생성
- 노드에 key prop이 있다면 => key prop 기준으로 교체가 필요한지 파악함
  - 상태 재설정할 때 유용함

##### 불필요한 리렌더링

> 리렌더링은 컴포넌트 상태가 변경되면 컴포넌트와 모든 자손 컴포넌트를 리렌더링 한다.

디핑 알고리즘은 필요한 변경사항을 최소화하여 효율적으로 업데이트하지만 이것이 불필요한 리렌더링까지 해결하지는 않는다.

이유는 **변경하지 않은 컴포넌트들도 리렌더링** 시킨기 때문
-> 이를 해결할려면?

- 상위 상태나 프롭이 변경되도 불필요한 리렌더링이 이뤄지지 않도록 관리가 필요
- 컴포넌트를 **구조화**시키고 **`memo`, `useMemo`와 같은 최적화 기능**을 사용

### 돌아보기

- 실제 DOM의 한계점
- 실제 DOM, 가상 DOM 차이점
- 가상 DOM을 사용했을 때 장점
- 실제 DOM과 가상 DOM의 한계점을 해결하는 방법
- React.createElement, document.createElement 차이점
- 디핑 알고리즘이 불필요한 리렌더링으로 이어질 수 있다

### 복습하기

- DOM이란 무엇이며, 가상 DOM과 어떻게 다른가요?

  - DOM : HTML을 트리형태 객체로 표현한 모델
  - 가상 DOM : 실제 DOM과 비슷한 구조를 가진 트리형 자바스크립트 객체
    - 실제 DOM 브라우저가 렌더링에 사용하는 구조 | 가상 DOM은 추상화된 자바스크립트 객체로 메모리에 존재
    - 가상 DOM은 메모리상에서만 존재하여 업데이트를 하여도 실제 DOM에 반영이 되지 않는다.
    - 가상 DOM은 변경사항을 계산 후 실제 DOM에 최소 변경 사항만 업데이트를 한다.

- 문서 조각이란 무엇이며, 리액트와 가상 DOM과 어떤 점에서 비슷하고 다른가요?

  - 문서 조각 : DOM 노드를 임시로 저장할 수 있는 가벼운 "컨테이너", 임시 저장소처럼 작동
    - 비슷한점 :
      - DOM 접근을 줄이는 중간 단계가 존재
      - 여러 업데이트 작업을 모아 한 번에 반영
    - 다른점 :
      - 문서조각은 직접 DOM을 조적, 가상DOM은 React 내부에서 처리
      - 문서 조각은 실제 DOM 객체, 가상 DOM은 트리형 자바스크립트 객체 형태
      - 가상 DOM은 비교 알고리즘(diffing)이 존재하여 이전, 현재 상태를 비교하여 최소 변경사항을 알 수 있다.

- DOM에서 문제가 되는 사안은 무엇인가요?

  - 성능 문제 :
    - 업데이트시 리플로, 리페인트 과정을 거쳐야하는데 이것이 비용이 비싸고 느림
  - 브라우저간 호환성 문제 :
    - 브라우저마다 DOM처리 방식이 다름
      - onChange 불일치
    - 네이티브 이벤트 처리가 일치하지 않음

- 사용자 인터페이스를 더 빠르게 업데이트하는 데 가상 DOM은 어떻게 활용되나요?

  - DOM을 직접 업데이트 하지않고 먼저 가상 DOM에서 이전, 새로운 가상 DOM과 비교하여 변경사항을 찾아내고 실제 DOM에 최소한 부분만 업데이트 합니다.
  - 여러번의 변경 사항이 있다면 모아서 한 번에 업데이트를 처리합니다.

- 리액트 렌더링은 어떻게 작동하나요? 이로 잠재된 어떤 문제가 발생하나요?
  - 상태나 prop이 변경되면 해당 컴포넌트는 리렌더링이 일어난다.
  - 이때 React Element 트리를 만들고 새로운 가상 DOM트리가 생성됨
  - 이전 가상 DOM 트리와 비교(diffing)작업이 진행
  - 변경된 부분을 찾아냈기에 이것을 실제 DOM에 업데이트함
  - 이때 불필요한 리렌더링이 일어날 수 있다.
    - 상태나 props가 변경되면 해당 컴포넌트와 자손컴포넌트들까지 리렌더링 됨
    - 이는 diffing 알고리즘이 있어도 리렌더링 발생 -> 성능저하
    - 이 문제는 컴포넌트를 분리화하거나 memo, useMemo와 같은 최적화 기능을 사용한다.
