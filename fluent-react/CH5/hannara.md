# Chapter 5 자주 묻는 질문과 유용한 패턴

### React.memo와 메모화

- **메모화(Memoization)**: 이전에 계산된 결과를 캐싱하여 함수의 성능을 최적화하는 기법
- **React.memo**: 함수형 컴포넌트의 불필요한 리렌더링을 방지하는 고차 컴포넌트
- **작동 원리**: 프롭이 변경되었을 때만 컴포넌트를 다시 렌더링하고, 그렇지 않으면 이전 결과 재사용
- **비교 방식**: 기본적으로 얕은 비교(shallow comparison)만 수행

> [!TIP] 메모화를 사용해야 할 때
>
> - 비용이 많이 드는 계산이 포함된 컴포넌트
> - 대량의 아이템을 렌더링하는 목록 컴포넌트
> - 부모 컴포넌트의 상태 변경으로 불필요하게 리렌더링되는 자식 컴포넌트

### useMemo와 useCallback

## useMemo

- 컴포넌트 내부의 계산값을 메모화
- 비용이 많이 드는 계산 결과를 캐싱
- 참조 타입(객체, 배열)의 참조 일관성 유지에 유용

## useCallback

- 함수를 메모화하는 훅
- 함수의 참조 일관성 유지에 사용
- 자식 컴포넌트에 전달되는 콜백 함수에 유용

> [!NOTE] 사용하지 말아야 할 경우
>
> - 간단한 연산이나 스칼라 값(문자열, 숫자, 불리언)에는 불필요
> - 브라우저 네이티브 엘리먼트(div, button)의 이벤트 핸들러에는 useCallback이 불필요

## 메모화 결정 기준

1. 계산 비용이 높은 연산인가?
2. 객체나 배열 같은 참조 타입인가?
3. 컴포넌트가 자주 리렌더링되는가?
4. React.memo로 감싸진 자식 컴포넌트에 전달되는가?

### 지연 로딩과 Suspense

## 지연 로딩(Lazy Loading)

- 필요한 시점에만 자원을 로드하는 기법
- 초기 번들 크기 감소와 로딩 시간 단축에 효과적
- React.lazy와 Suspense를 함께 사용

## Suspense

- 비동기 컴포넌트의 로딩 상태를 처리하는 컴포넌트
- fallback prop으로 로딩 중 UI 지정
- try/catch와 유사한 방식으로 작동

```jsx
// 권장하는 방식
<div>
  <Header />
  <Suspense fallback={<SkeletonUI />}>{showComponent && <LazyComponent />}</Suspense>
  <Footer />
</div>
```

> [!TIP] 효과적인 Suspense 사용법
>
> - 전체 앱을 감싸지 말고 지연 로딩되는 컴포넌트만 감싸기
> - 스켈레톤 UI와 함께 사용하여 사용자 경험 향상
> - 로딩 중에도 나머지 UI는 사용 가능하게 유지

### useState와 useReducer 비교

| 측면               | useState               | useReducer                     |
| ------------------ | ---------------------- | ------------------------------ |
| 적합한 경우        | 단순한 상태 관리       | 복잡한 상태와 상태 전이 로직   |
| 코드 길이          | 간결함                 | "상대적"으로 장황함            |
| 상태 업데이트 로직 | 컴포넌트 내부에 위치   | 컴포넌트에서 분리 가능         |
| 테스트 용이성      | 컴포넌트와 함께 테스트 | 별도로 테스트 가능             |
| 상태 변경의 명시성 | 암시적일 수 있음       | 항상 명시적 (액션 타입으로)    |
| 이벤트 추적        | 어려움                 | 액션으로 이벤트 흐름 파악 용이 |

## Immer와 함께 사용

- 중첩된 상태 구조에서 불변성을 유지하며 직관적인 코드 작성 가능
- useImmerReducer: 마치 변경 가능한 것처럼 상태 업데이트 가능

```jsx
// Immer 없이
setState({ ...state, user: { ...state.user, name: newName } });

// Immer 사용
produce((draft) => {
  draft.user.name = newName;
});
```

### 리액트 디자인 패턴

## 프레젠테이션/컨테이너 패턴과 고차 컴포넌트 비교

| 패턴      | 프레젠테이션/컨테이너   | 고차 컴포넌트(HOC)               |
| --------- | ----------------------- | -------------------------------- |
| 목적      | UI와 로직 분리          | 여러 컴포넌트 간 로직 공유       |
| 구현 방식 | 두 개의 분리된 컴포넌트 | 다른 컴포넌트를 감싸는 함수      |
| 현재 상황 | 훅으로 대체 가능        | 훅으로 대체 가능하나 여전히 유용 |
| 사용 예시 | -                       | React.memo, forwardRef           |

## 렌더 프롭, 제어 프롭, 복합 컴포넌트

**렌더 프롭**:

- 컴포넌트의 렌더링 로직을 함수 프롭으로 전달
- 훅으로 대체 가능해 사용 빈도 감소
  <br />

**제어 프롭**:

- 컴포넌트가 외부 제어와 내부 상태 관리를 모두 지원
- 제어 모드와 비제어 모드 모두 가능

```jsx
// 둘 다 지원하는 컴포넌트
<Toggle on={controlledState} onToggle={handleToggle} /> // 제어 모드
<Toggle /> // 비제어 모드
```

<br />

**복합 컴포넌트**:

- 서로 연결된 컴포넌트들이 상태를 공유하며 독립적으로 렌더링
- Context API로 구현
- 유연한 UI 구성 가능

```jsx
<Accordion>
  <AccordionItem item={item1} />
  <hr /> {/* 중간에 다른 요소 삽입 가능 */}
  <AccordionItem item={item2} />
</Accordion>
```

## 프롭 컬렉션, 프롭 게터, 상태 리듀서

**프롭 컬렉션과 프롭 게터**:

- 관련 프롭들을 묶어 재사용
- 게터 함수로 기본 동작 유지하며 사용자 정의 가능

```jsx
// 프롭 컬렉션
<Dropzone {...droppableProps} />

// 프롭 게터
<Dropzone {...getDroppableProps({ onDrop: customHandler })} />
```

<br />

**상태 리듀서**:

- 컴포넌트의 내부 상태 로직을 외부에서 확장 가능
- 코드 변경 없이 컴포넌트 동작 사용자 정의 가능

```jsx
<Toggle
  stateReducer={(state, action) => {
    // 특정 조건에서 상태 변경 방지 등 로직 추가
    return action.changes;
  }}
/>
```

> [!NOTE] 패턴 선택은 어떨 때?
>
> - 단순한 앱: 훅만으로 충분할 수 있음
> - 복잡한 컴포넌트: 여러 패턴을 조합하여 유연성과 재사용성 확보
> - 코드 유지보수: 일관된 패턴 사용으로 팀 협업 효율성 증대

## 복습하기

1. 리액트에서 메모화란 무엇이며 , 컴포넌트 렌더링을 최적화하는 데 어떻게 사용할 수 있을까요 ?

- 메모화 : 이전에 계산된 결과를 캐싱하여 함수의 성능을 최적화하는 기법.
- React에서는 메모화를 위한 함수를 제공하며 상황에 따라 적절히 사용할 수 있습니다.
  - React.memo : 함수형 컴포넌트드를 래핑하여 prop이 변경되지 않을 때 불필요한 리렌더링을 방지할 수 있습니다.
    - prop이 같다면 이전의 렌더링 결과를 재사용합니다.
  - useMemo : 컴포넌트 내부의 계산값을 메모화합니다.
    - 의존성 배열이 변경되지 않는다면 이전의 계산 결과를 재사용합니다.
  - useCallback : 함수 자체를 메모화합니다.
    - 의존성 배열이 변경되지 않는다면 함수 참조를 유지합니다.

2. 리액트에서 상태 관리를 위해 useReducer를 사용하면 어떤 우세한 점이 있으며 , useReducer는 usestate 와 어떻게 다른가요 ?

- 컴포넌트에서 상태 관리 로직을 분리할 수 있습니다. -> 독립적인 테스트 가능
- 상태 변경을 명시적으로 표현하여 명확한 흐름을 알 수 있습니다.

3. React. Lazy 와 Suspense 컴포넌트를 사용하는 리액트 애플리케이션에서 지연 로딩을 어떻게 구현할 수 있나요 ?

- React.lazy로 정의한다면 import문을 사용해 지연 로딩을 구현합니다.
- Suspense 컴포넌트로 지연 로딩을 해야하는 컴포넌트를 감쌉니다.
  - fallback UI를 제공합니다.

4. 리액트에서 메모화를 사용할 때 발생할 수 있는 잠재적 문제는 무엇이며 어떻게 완화할 수 있을까요 ?

- 메모화하는 것 또한 비용이 들어가는 작업이기에 가벼운 연산 때 사용한다면 불필요한 연산이 존재할 수 있습니다.
- 메모화는 "얕은 비교"를 수행하여 참조 타입을 렌더링 마다 새로 생성한다면 메모화의 장점이 없습니다.
- 의존성 배열의 값이 불완전하다면 사이드이펙트가 발생할 수 있습니다.
- 무분별한 메모화는 코드 복잡성을 증가시킬 수 있고 성능 저하를 일으킬 수 있습니다.
- 완화법 :
  - 계산 비용이 높을 때만 사용
  - useMemo, useCallback을 적절히 사용
  - 명확한 의존성 배열 사용

5. 리액트에서 컴포넌트에 프롭으로 전달된 함수를 메모화하기 위해 useCalLback 훅을 어떻게 사용할 수 있나요?

- 네이티브 엘리먼트(button, div)와 같은 이벤트 핸들러에 사용하지 않습니다.
- React.memo로 감싼 자식 컴포넌트에 함수를 전달해야할 때 사용하면 좋습니다.
- 자주 리렌더링 되는 컴포넌트에서 이벤트 핸들러를 정의해야할 때
