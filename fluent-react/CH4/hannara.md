# Chapter 4 재조정

> 목록
> 4.1 재조정 이해하기
> 4.2 일괄 처리
> 4.3 기존 기술
> 4.3.1 스택 재조정자
> 4.4 파이버 재조정자
> 4.4.1 데이터 구조로서의 파이버
> 4.4.2 더블 버퍼링
> 4.4.3 파이버 재조정 - 렌더링 단계 - beginWork(작업 시작) - completeWork(작업 완료) - 커밋 단계 - 변형 단계 - 레이아웃 단계 - 효과 - 화면에 모두 표시하기
> 4.5 돌아보기
> 4.6 복습하기

이전까지 JSX와 React.createElement, 가상 DOM을 공부함
이제 가상 DOM을 적용하는 방법과 ReactDOM.createRoot(element).render() 동작, 가상 DOM을 구상하고 재조정(reconiliation) 과정을 배움

### 재조정 이해하기

> [!note]
> 가상 DOM은 UI 상태의 청사진이다.
> 리액트는 이 "청사진"을 가지고 **재조정**이라는 프로세스를 통해서 렌더링 한다
> "청사진" = 프로젝트 구조나 디자인을 "미리 설계하는 과정(설계도)"를 말함
> 설계도 = 목표 건물을 명시하는 도면

- JSX는 리액트 엘리먼트의 트리
  - 우리가 그리고자하는 UI의 "상태" !== 실제 UI상태
    - 리액트 엘리먼트는 React.createElement, JSX "<"기호로 생성됨
- 첫 렌더링 때 트리형태로 리액트 엘리먼트 트리가 표시됨
  - **최소 필요한 DOM API**만 호출해 브라우저에 반영
    - 필요한 DOM API호출을 어떻게 최소화할까?
    - -> 가상 DOM 변경사항을 실제 DOM에 한 번의 업데이트로 **"일괄처리"**

### 일괄 처리

이전 챕터에서 DOM API의 문서 조각(document fragment)를 본다면 실제 DOM에 영향을 주지않고 변경사항을 한 번에 반영한다.

이와 비슷하게 리액트 재조정 과정에서는 가상 DOM 업데이트들을 한번에 DOM 업데이트로 모아서 처리한다.

![[스크린샷 2025-04-18 오후 3.58.16.png]]

- handleClick 함수가 한번에 세 번 연속 호출하여 DOM은 3번 업데이트가 되어야하지만 리액트의 일괄처리로 한 번에 업데이트를 수행하여 count + 3으로 업데이트
  - 가상 DOM을 복제해 새로운 가상 DOM을 생성 -> 업데이트된 값(+3)을 적용
  - 이런 일괄 처리는 재조정의 일부.

### 4.3 기존기술

> 과거의 "스택 재조정자"를 사용한 재조정 방법을 먼저 설명

#### 4.3.2 스택 재조정자

- stack은 선형 데이터 구조로 LIFO(Last In First Out)원칙을 따름
- 예전 리액트 재조정자는 "스택 기반 알고리즘"을 사용해 이전, 새 가상 트리를 비교하여 DOM업데이트를 진행
  - 이때 **발생되는 문제**
    - 1. 작업을 일시중지나 미루지 않고 순차적으로 변경 사항을 렌더링 시킴
    - -> 만약 계산 비용이 비싼 컴포넌트가 존재하여 렌더링을 막으면 화면이 버벅임 -> UX 망함
      - 만약 계산 비용이 큰 컴포넌트 렌더링의 우선순위를 높게 설정하면 미뤄질 일이 없다고 생각됨
      - 그러나 **스택 재조정자는 업데이트의 우선순위 설정은 없다.**
    - 2. 업데이트를 중단 또는 취소를 하지 못함
      - 우선순위를 줄 수 있다고 가정해도 덜 중요한 업데이트 중단을 하지 못함
        - -> 개발자는 이를 해결하기 위해 토스트 알림창 같은 방법을 채택함
    - **정리** : 어플리케이션 사이즈가 커지고 복잡성이 증가하여 끊김문제와 느린 응답속도 문제가 존재함

### 4.4 파이버 재조정자

> 위와같은 문제를 해결하기 위해 리액트 팀은 **파이버 트리** 데이터 구조를 기반하는 **파이버 재조정자**를 개발

> 파이버 재조정자는 **파이버**라는 데이터 구조가 사용됩니다.
>
> - 리액트 엘리먼트에서 생성됨
>   - 차이점 :
>     - 파이버는 상태를 저장하고 수명이 길다. vs 리액트 엘리먼트는 임시적, 상태가 없다.

#### 4.4.1 데이터 구조로서의 파이버

> 파이버 데이터 구조는 **"파이버 재조정자의 핵심 요소"** 로 업데이트 우선순위를 정하여 동시 실행을 가능하게함

- 파이버 데이터 구조는 리액트에서 컴포넌트 인스턴스와 상태를 표현합니다.
- *변경 가능한 인스턴스*로 설계되고 조정과정에 *필요에 따라 업데이트*되고 *재배치*됨
  - 파이버 노드 인스턴스
    - 컴포넌트에 대한 정보:
      - props
      - state
      - 하위 컴포넌트
      - 컴포넌트 트리의 위치 정보
      - 메타데이터 (업데이트 우선순위를 정할 때 필요한 정보)

```js
// 파이버 노드 예시
{
tag: 3, // ClassComponent = 3
type: App,
props : {
	name: "Tejas",
	age: 30
},
stateNode: AppInstance,
...
}
```

위 예시는 파이버 노드에 대한 예시이며 다음과 같은 컴포넌트 정보가 존재

- ##### tag
  - 3으로 보이는 것이 tag값이며 리액트는 이것을 기준으로 Class Component로 식별함
  - 컴포넌트 유형마다 고유한 ID가 존재하고 이것이 파이버로 설정됨
    - Class Component(= 1), Function Component(= 0), Suspence, fragment(= 7) ...
    - 찾아보니 tag 3은 HostRoot라고 합니다..? (책이 잘못된건가?)
    - [react-conciler/src/ReactWorkTag.js](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactWorkTags.js) 참고![[스크린샷 2025-04-18 오후 4.44.22.png]]
- ##### type
  - 파이버가 나타내는 함수 또는 Class Component를 나타낸다.
- ##### props
  - 컴포넌트에 대한 입력 prop 또는 함수에 대한 입력 인수를 나타냅니다.
- ##### stateNode

  - 파이버가 나차내는 App 컴포넌트의 인스턴스.
  - 컴포넌트 트리에서 위치는 return(qnah), child(자녀), sibling(형제), index(파이버 색인) 등으로 표현
  - 파이버 재조정자는 이를 사용해 트리를 순회함

- 파이버 재조정에서는 현재의 파이버 트리와 다음 파이버 트리를 비교해 어떤 노드를 업데이트, 추가, 제거하는 작업도 포함

##### 파이버 재조정 중 파이버 노드를 생성 하는 과정?

- 조정 과정에 **파이버 재조정자**는 가상 DOM의 리액트 엘리먼트에 대한 파이버 노드를 생성
  - createFiberFromTypeAndProps 함수 수행
    - createFiberFromTypeAndProps는 엘리먼트에서 파생된 파이버를 반환
- 파이버 노드가 생성되면 **파이버 재조정자**는 **작업 루프(work loop)**를 사용해 UI를 업데이트함
  - 작업 루프는 루트 파이버 _노드부터 컴포넌트 트리를 따라 내려가 순회_ ->
  - 브라우저 DOM트라와 _분리된 새로운 DOM트리를 메모리에 생성_ ->
  - 새로운 DOM트리는 화면에 반영 (flushed)
    - 위 작업을 함수로 표현한다면?
      - 작업 시작(beginWork) = 위에서 아래로 이동함
        - 이동하면서 "업데이트가 필요함"을 표시
      - 작업 완료(completeWork)는 다시 위로 이동함
        - 분리된 실제 DOM 엘리먼트의 트리를 메모리를 구성함
    - 위 작업들은 사용자가 볼 수 없고 , *언제든지 중단, 삭제*가 가능
  - 파이버 아키텍처는 이런 작업들을 화면 밖에서 준비하고 화면에 내보는 것을 **"더블 버퍼링"** 이라는 개념에서 가져옴

#### 4.4.2 더블 버퍼링

> [!note] > **더블 버퍼링?**
> 컴퓨터 그래픽 및 비디오 처리에서 깜빡임을 줄이고 성능 개선하는 기술
>
> - 이미지나 프레임을 저장하기 위한 *두 개의 버퍼(메모리 공간)을 생성*하여 일정한 간격으로 버퍼들을 전환해 최종 이미지나 동영상을 표시
> - 작동 방식
>   - 첫 번째 버퍼(1버퍼)가 초기 이미지 또는 프레임으로 채워짐
>   - 1버퍼가 표시되는 동안 두 번째 버퍼(2버퍼)가 새 데이터, 이미지로 업데이트
>   - 2버퍼가 준비되면 1버퍼로 전환, 화면에 표시
>   - 일정한 간격으로 1버퍼, 2버퍼가 전환되어 최종 이미지, 동영상을 표시하는 프로세스가 돌아감

- 파이버 재조정에서는 업데이트가 발생하면 파이버 트리가 포크됨 ->
- 사용자 인터페이스의 새로운 상태를 반영하도록 업데이트 === **렌더링**
- 이후 현재 트리를 대체할 트리가 준비되고 사용자가 기대하는 상태를 정확하게 반영
- 이 두 트리가 "더블 버퍼링"처럼 현재 파이버 트리와 교체함
  - 재조정의 **커밋 단계 또는 커밋** 이라고 부름
- 즉 파이버 재조정를 사용하면 JSX엘리먼트 정의 트리에서 2개의 트리가 생성

  - "현재" 파이버를 포함하는 트리 , 작업용 파이버를 포함한 트리
  - 이 두가지 내용을 4.4.3으로 넘겨 더 자세히 알아봄

- 이런 화면에 표시되지 않는 작업용 트리를 사용할 때 장점
  - 실제 DOM에 **불필요한 업데이트를 피함**
  - 화면 밖에서 UI상태를 계산할 수 있음
    - 만약 계산 중 더 중요한 업데이트가 필요하면 **이를 버릴 수 있음**
  - 재조정은 화면 밖에서 이뤄져서 일단 보이고 있는 내용을 멈추지 않고 **중단 또는 재시작이 가능**

#### 4.4.3 파이버 재조정

> 파이버 재조정은 **"렌더링 단계", "커밋 단계"** 로 이뤄짐
> ![[스크린샷 2025-04-18 오후 5.04.13.png]]

##### 렌더링 단계

- **렌더링 단계**

  - _작업 시작(beginWork)_

    - 작업용 트리의 파이버 노드의 업데이트 필요 여부를 나타내는 _플래그_ 설정
    - 다음 파이버 노드로 이동하며 트리 맨 아래까지 동일한 작업 수행
    - 작업 완료하면 파이버 노드에서 completeWork를 호출하고 다시 올라가며 순회
    - ![[스크린샷 2025-04-18 오후 5.10.44.png]]

      - current :
        - 현재 트리(업데이트 중인 작업용 노드)의 파이버 노드에 대한 **참조**
        - 트리의 이전 버전과 새 버전 간 변경 사항와 **업데이트 사항을 결정할 때 사용**
        - 불변 값 , **비교용으로만 사용**
      - workInProgress :
        - **작업용 트리**에서 **업데이트 중인 파이버 노드**
        - beinWork 함수에 의해 업데이트
        - "더티"로 표시된채 반환
      - renderLanes
        - 파이버 재조정자에서 기존 `renderExpirationTime`을 **대체하는 새로운 개념**
        - 업데이트가 처리되는 레인(lane)을 나타내는 비트마스크(bitmask)
          - 레인 : 우선순위를 포함해 **여러 기준을 따라 업데이트를 분류하는 방식**
          - 비트마스크 : 이진수를 사용하는 컴퓨터의 연산 방식을 이용한, **정수의 이진수 표현을 자료 구조**로 쓰는 기법
          - 컴포넌트를 변경하면 여러 특성에 따른 레인이 할당 (우선순위가 높을수록 더 높은 레인이 할당)
        - 업데이트가 올바른 순서로 처리되기위해 renderLanes값은 beginWork함수에 전달
          - 우선순위가 높은데로 우선적으로 처리됨
        - 리액트 동시성을 관리하도록 지원
          - **타임 슬라이싱**을 사용해 실행시간이 긴 업데이트를 더 작은 덩어리로 분할
            - renderlanes는 어떤 업데이트를 처리할 지 결정하기에 타임 슬라이싱할 때 사용됨
        - 렌더링 단계가 완료되면 `getLanesToRetrySynchronouslyOnError`함수를 호출해 미뤄진 업데이트가 있는지 확인함 =>
          - 만약 있다면 updateComponent함수는 새로운 루프를 타고 beginWork, getNextLanes를 사용해 업데이트 처리 -> 레인에 따라 우선순위 지정
        - 정리 : renderLanes는 기존 개념을 대체, renderLanes값을 **beginWork함수에 전달해 우선순위 대로 처리** , **리액트 동시성 관리**할 때도 사용됨

    - _작업 완료(completeWork)_
      - 작업용 파이버 노드에 업데이트 적용, **업데이트 된 상태를 나타내는 실제 DOM트리를 생성**
      - 분리된 트리를 브라우저 밖에 구성함
      - 만약 우선순위가 높은 업데이트가 예약되면 만들어진 UI는 여기서 버려짐 (파이버 재조정자 기능 핵심)
      - completeWork 시그니처
        - ![[스크린샷 2025-04-18 오후 5.24.24.png]]
        - beginWork는 파이버 노드에 **"업데이트 필요"상태 플래그를 설정**하는 역할
        - completeWork는 **호스트 환경에 커밋할 새로운 트리를 구성**하는 역할
        - completeWork가 **트리 맨 위에 도달해 새로운 DOM트리를 구성**하면
          - 렌더링 단계가 완료되었다고 보고 커밋단계로 넘어감

##### 커밋 단계

![[스크린샷 2025-04-18 오후 5.06.50.png]]

> 커밋 단계에서는 렌더링 단계에서 가상 DOM에 적용된 변경사항들을 실제 DOM에 반영하는 단계.
> 새 가상 DOM트리가 호스트 환경에 커밋되고 작업용 트리가 현재 트리로 바뀌어짐

- **변형 단계**

  - 커밋단계의 첫 부분
  - 가상 DOM에 적용된 변경 사항을 **실제 DOM에 반영**
  - 적용할 업데이트를 식별, `commitMutationEffects`함수를 호출
    - `commitMutationEffects` = 렌더링 단계에서 작업용 트리의 파이버 노드에 적용된 업데이트를 실제 DOM에 반영
    - 이 단계에서 리액트는 `commitUnmount`, `commitDeletion` 등을 호출해 필요하지 않은 노드를 DOM에서 제거하기도함
    - ![[스크린샷 2025-04-18 오후 5.30.11.png]]

- **레이아웃 단계**

  - 커밋 단계의 두 번째 부분
  - DOM에서 업데이트된 노드의 **새로운 레이아웃 계산**
  - commitLayoutEffect를 호출
  - 이 단계가 완료되면 가상 DOM에서의 변경 부분을 실제 DOM에 반영
  - 커밋 단계와 레이아웃 단계로 나눠 DOM업데이트를 효율적으로 적용함

- **효과**
  브라우저 페인트 가능 시점 후에 실행되도록 예약된 **사용자 정의 효과**.
  use Effect 훅을 사용해 관리됨

      - 배치 효과
      	- 새로운 컴포넌트가 DOM에 추가될 때 발생
      	- ex) form에 새로운 button이 **추가되면 배치 효과**가 발생 -> DOM에 추가
      - 업데이트 효과
      	- 컴포넌트가 새로운 prop이나 상태로 업데이트될 때 발생
      	- ex) button text가 **변경되면 업데이트 효과** 발생 -> DOM에 텍스트 업데이트
      - 삭제 효과
      	- 컴포넌트가 DOM에서 제거될 때 발생
      	- ex) from에서 button이 **제거되면 삭제 효과** 발생 -> DOM에서 삭제
      - 레이아웃 효과
      	- 브라우저 페인트 가능 시점 전 에 발생해 레이아웃 업데이트함
      	- ex) useLayoutEffect, componentDidUpdate 를 사용해 관리

- **화면에 모두 표시하기**
  - 현재 트리 또는 작업용 트리 중 하나에 FiberRootNode를 두게 된다.
  - 가상DOM이 업데이트되면 "작업용 트리"를 업데이트 진행
    - 현재 상태를 유지하면서 가상 DOM을 계속 렌더링 할 수 있음
  - 렌더링 프로세스가 완료되면 commitRoot함수를 호출해 **작업용 트리에 적용된 변경사항을 실제 DOM에 커밋**
    - commitRoot는 FiberRootNode의 포인터를 현재 트리에서 작업용 트리로 전환, 작업용 트리를 현재 트리로 변경
    - 이 시점을 기준으로 모든 업데이트는 현재 트리 기반으로 이뤄짐

### 복습하기

- 리액트의 재조정이란 무엇인가요?

  가상 DOM을 사용해 실제 DOM을 효율적으로 업데이트하는 "프로세스"입니다.

  - 재조정 : 이전, 새로운 가상 DOM을 비교해 변경 사항을 **"식별"**
  - 식별한 변경사항만 한 번에 실제 DOM에 업데이트

- 파이버 데이터 구조 역할은 무엇인가요?

  재조정을 효율적으로 하게끔하고 동시에 여러 작업을 처리하게끔하는 것

  - 업데이트 우선순위 표시
  - 작업 일시 중지, 다시 시작, 삭제 하기

- 왜 트리가 두 개 필요한가요?

  파이버에서 채택된 "더블 버퍼링"을 채택해서 두 개의 파이버 트리를 사용해 서로 교체해가며 끊김없는 화면 렌더링을 하기 위해,

  도중 작업을 중단, 다시 시작, 삭제를 할 수 있게 하기 위해

- 애플리케이션이 업데이트되면 어떻게 되나요?

  상태, prop이 변경 -> 새로운 가상 DOM생성 -> 파이버 재조정 동작 -> 렌더링 단계 거침 (아직 DOM에 반영 안됨) -> 커밋 단계 (실제 DOM에 반영) -> 실제 DOM에 적용되어 리페인트 작업 수행 -> 화면 업데이트 -> 파이버 트리 업데이트하여 다시 생성할 준비
