# 입문자를 위한 지식

> 단순한 사용법을 넘어 리액트의 동작원리
> 
- 왜 존재하게 되었는지, 어떻게 동작하는지, 어떤 문제를 해결하려고 작성되었는지, 처음 만들어질 때의 의도와 설계

## 1.1 리액트는 왜 필요한가요?

> 즉각적인 업데이트
> 
- 새 페이지가 렌더링되고 로딩되기까지 기다릴 필요없이 즉시 업데이트되어 내용을 바로 확인하고싶어함.

## 1.2 리액트 이전의 세계

- 오류가 쉽게 생김
    - 예를들어 이벤트 관련해서 addEventListener 를 사용 후 removeEventListener 를 안하면 ..?
- 예측이 불가함
    - 실수로 id가 동일 한 엘리먼트가 여러개라면,
    - 엘리먼트가 존재하지않는다면,
    - 예상가능 한 부분은 케이스별로 대응하면 되지만, 미처 예상하지 못한 부분에서 side-effect 발생
- 비효율
    - 변경사항이 일어날 때 마다 DOM이 업데이트…
- 이러한 문제를 해결하기 위해 나온 솔루션들
    - jQuery
        - 장점) 사용자 인터페이스 자체를 직접 조작하여 사용하기 쉽다는 장점이있지만
        - 단점) 크기 및 로딩 시간이 너무 컸고 성능적으로 네이티브 자바스크립트 메서드가 계속 개선되어 더이상 사용할 의미를 잃음
    - Backbone
        - mvc 패턴
            - 모델
                - 데이터와 비즈니스 규칙 담당
            - 뷰
                - 사용자 인터페이스, 사용자 명령을 컨트롤러로 전달, 모델이 표시할 데이터를 제공할 때 까지 기다리며 데이터를 직접 가져오거나 저장하지 않음
            - 컨트롤러
                - 모델과 뷰 사이 인터페이스 역할
                - 모델을 뷰에서 분리해 시스템 아키텍처를 더욱 유연하게 만듬
        - 양방향 데이터 바인딩
            - 뷰가 모델과 동기화 되지 않거나 반대로 모델이 뷰와 동기화되지 않는 문제가 일어날 수 있음
        - 강한 결합
            - 모델 뷰 컨트롤러가 강하게 결합되어 다른 구성 요소에 영향을 주지않고 독립적으로 하나만 변경하거나 리팩터링하기 어려울 수 있음
        - 장황한 코드 및 보일러플레이트
        - 이벤트 중심 아키텍처
    - Knockout
        - 옵저버블과 바인딩을 작성하는 방법을 제공하는 라이브러리
            - 상태가 변경될 때마다 옵저버블과 바인딩을 활용해 의존성을 추적함
                - 옵저버블 : 데이터의 출처 (== 모델)
                - 바인딩 : 해당 데이터를 소비하고 렌더링하는 사용자 인터베이스 (== 뷰)
        - 최초의 반응형 자바스크립트 라이브러리
            - 관찰 가능한 방식으로 상태 변화에 따라 값을 업데이트 함
        - MVVM 패턴
            - 모델
            - 뷰
            - 뷰모델
        - MVC vs MVVM

            ![Image](https://github.com/user-attachments/assets/bc000c05-d874-491e-b664-9c54af557a98)
            
    - 앵귤러JS
        - 2010년 구글에서 개발
        - 양방향 데이터 바인딩
        - 모듈식 아키텍처
        - 앵귤러 JS 트레이드오프
            - 성능 문제
            - 복잡성
            - 앵귤러 2가 나오며 1과 하위호환이 되지않아 업그레이드 마이그레이션 하기에 큰 혼란이있음
            - 복잡한 템플릿 문법으로 인한 유지보수 어려움
            - 타입 안정성 부재

## 1.3 리액트 등장

> 컴포넌트 기반 아키텍처
> 
- JSX, 컴포넌트 모델 도입
- DOM 조작을 최소화 함 → 성능 향상
- 단방향 데이터 흐름 : 애플리케이션을 더잘 제어하고 시간에 따라 데이터가 어떻게 변화하는지 더쉽게 이해할 수 있게 함
- 선언적 코드와 명령형 코드
    - 우리가 보고자하는 것을 코드로 표현
    - 어떻게 할지? → 리액트가 알아서 함
    - 따라서, 예측 가능하며 효율적으로 생성되고 작동할 수 있도록 보장
- 불변 상태
    - 각각의 상태 업데이트는 새로운 독립된 스냅숏과 메모리 참조로 취급됨
    - 불변성을 강제함으로 UI 컴포넌트가 특정 시점의 특정 상태를 반영하도록 보장
    - 상태가 변경되면 새로운 상태를 표현하는 새 객체 반환
    - 모든 상태 전환은 독립적이고 서로 간섭하지 않음
- 플럭스 아키텍처

    ![Image](https://github.com/user-attachments/assets/f9344bc7-cf00-49f7-a9fb-9a35aed0cbe7)

    - 액션
        - 단순한 객체
        - 디스패처를 통해 여러 스토어로 보내짐
    - 디스패처
        - 액션을 받아서 애플리케이션에 등록된 스토어로 보냄
        - 모든 스토어는 디스패처에 스토어 자신과 콜백을 등록하는데 이 목록을 관리하는 것 또한 디스패처 역할
    - 스토어
        - 애플리케이션 상태와 로직을 포함함
        - 다수 객체의 상태를 관리함
        - 스토어 상태가 업데이트되면 변경이벤트를 발생시켜 뷰에 변경된 사항을 알림
    - 뷰
        - 컴포넌트
        - 스토어에서 변경 이벤트를 받으며 의존하는 데이터가 변경되면 스스로 업데이트 함
    - 장점
        - 단일 정보 출처
        - 테스트 가능성을 높임
        - 관심사 분리

## 1.4 그래서_ 리액트는 왜 필요한가요?

> 더 예측 가능하고 신뢰성 있는 방식으로 사용자 인터페이스를 작성할 수 있게하고 우리가 화면에 나타내고자 하는 바를 선언적으로 표현할 수 있게 함
> 
- 컴포넌트 기반 아키텍처
- 선언적 프로그래밍 모델
- 가상DOM
- JSX
- 광범위한 생태계
- 플랫폼을 가리지 않는 특성
- 메타의 지원

## 1.5 돌아보기

- 리액트 간략한 역사
- 핵심 가치
- 불안전하고 예측할 수 없으며 비효율적인 대규모 사용자 인터페이스 업데이트 문제 해결하는 방법
- 컴포넌트 모델

## 1.6 복습하기

- 리액트를 만들게 된 동기가 무엇인가요?
    - 더 예측 가능하고, 신뢰성 있게 편리하게 화면에 나타내고자
- 리액트가 MVC와 MVVM 같은 이전 패턴보다 개선된 점은 무엇인가요?
    - 단방향 데이터 흐름, 컴포넌트 기반 아키텍처, 명시적인 상태관리, 가상DOM, 선언적 프로그래밍 (어떤 상태일때 어떤 UI를 보여줘야하는지)
- 플럭스 아키텍처 특징은 무엇인가요?
    - 기존 패턴 기반하여 확장된 컴포넌트로, 관심사의 분리가 강화
- 선언적 프로그래밍 추상화의 장점은 무엇인가요?
    - 무엇을 할지 보여주고 어떻게할지는 감추는 것
    - 가독성 향상, 재사용성 모듈화, 상태와 UI 동기화
- 효율적인 UI 업데이트를 위한 가상DOM의 역할은 무엇인가요?
    - 실제로 변경된 부분만 감지하여 해당 부분만 실제 DOM에 변경 하는 방식으로 성능 향상

## 1.7 미리보기

- 선언적 추상화
- JSX 구문 및 내부 동작

## REFERENCE

https://www.youtube.com/watch?v=8pDqJVdNa44